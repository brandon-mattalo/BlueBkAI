<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BlueBook Writing Platform</title>
    
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Lexend:wght@300;400;500;600&family=Roboto+Mono:wght@400;500&display=swap');

        :root {
            --bg-color: #1a1a2e;
            --primary-color: #16213e;
            --secondary-color: #0f3460;
            --accent-color: #e94560;
            --text-color: #dcdcdc;
            --glass-bg: rgba(255, 255, 255, 0.05);
            --glass-border: rgba(255, 255, 255, 0.2);
        }

        body {
            font-family: 'Lexend', sans-serif;
            background: var(--bg-color);
            color: var(--text-color);
            background: linear-gradient(45deg, #1a1a2e, #16213e, #0f3460);
            min-height: 100vh;
        }

        .glass-ui {
            background: var(--glass-bg);
            backdrop-filter: blur(10px);
            border-radius: 1rem;
            border: 1px solid var(--glass-border);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
            transition: all 0.3s ease;
        }

        .glass-ui:hover {
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.57);
            transform: translateY(-5px);
        }

        #essay-content[contenteditable="true"] {
            font-family: 'Roboto Mono', monospace;
            background: rgba(0,0,0,0.2);
            border: 1px solid var(--glass-border);
            min-height: 70vh;
            padding: 2rem;
            border-radius: 1rem;
            line-height: 1.8;
            font-size: 1.1rem;
            color: var(--text-color);
            overflow-y: scroll;
            scroll-behavior: smooth;
        }

        #essay-content[contenteditable="true"]:focus {
            outline: none;
            border-color: var(--accent-color);
            box-shadow: 0 0 0 3px rgba(233, 69, 96, 0.4);
        }
        
        .format-buttons {
            display: flex;
            flex-wrap: nowrap;
            gap: 0.5rem;
            margin-bottom: 1rem;
            padding: 1rem;
            overflow-x: auto;
        }

        .format-buttons button, .format-buttons select {
            background: var(--glass-bg);
            border: 1px solid var(--glass-border);
            color: var(--text-color);
            padding: 0.5rem;
            border-radius: 0.5rem;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }

        .format-buttons button svg {
            width: 1.25rem;
            height: 1.25rem;
        }

        .format-buttons button:hover, .format-buttons select:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: var(--accent-color);
        }

        .format-buttons button.active {
            background: var(--accent-color);
            color: white;
        }

        .view-switcher button {
            padding: 0.75rem 1.5rem;
            border-radius: 0.75rem;
            font-weight: 600;
            transition: all 0.2s ease-in-out;
            cursor: pointer;
            border: 1px solid var(--glass-border);
        }

        .view-switcher button.active {
            background-color: var(--accent-color);
            color: white;
            box-shadow: 0 4px 10px rgba(233, 69, 96, 0.3);
        }

        .view-switcher button:not(.active) {
            background-color: var(--glass-bg);
            color: var(--text-color);
        }

        .view-switcher button:not(.active):hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        .ai-alert, .success-message {
            padding: 1rem;
            border-radius: 0.5rem;
            margin-top: 1rem;
            border-left: 4px solid;
        }

        .info-box {
            background: rgba(255, 255, 255, 0.07);
            border: 1px solid rgba(255, 255, 255, 0.15);
            padding: 1rem;
            border-radius: 0.75rem;
        }

        .ai-alert {
            background-color: rgba(220, 53, 69, 0.1);
            border-color: #dc3545;
        }

        .success-message {
            background-color: rgba(25, 135, 84, 0.1);
            border-color: #198754;
        }

        .spinner {
            border: 4px solid rgba(255,255,255,0.2);
            border-top: 4px solid var(--accent-color);
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Light Mode Styles */
        .light-mode {
            --bg-color: #eef1f5;
            --primary-color: #ffffff;
            --secondary-color: #e9ecef;
            --accent-color: #007bff;
            --text-color: #212529;
            --glass-bg: rgba(255, 255, 255, 0.45);
            --glass-border: rgba(255, 255, 255, 0.8);
        }

        .light-mode body {
            background: var(--bg-color);
            color: var(--text-color);
            background: linear-gradient(to bottom right, #e6e9f0 0%, #eef1f5 100%);
        }

        .light-mode .glass-ui {
            background: var(--glass-bg);
            border: 1px solid var(--glass-border);
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.1);
        }

        .light-mode #essay-content[contenteditable="true"] {
            background: rgba(255, 255, 255, 0.75);
            border-color: var(--glass-border);
            color: var(--text-color);
        }

        .light-mode #essay-content[contenteditable="true"]:focus {
            border-color: var(--accent-color);
            box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.25);
        }

        .light-mode .format-buttons button, .light-mode .format-buttons select {
            background: var(--glass-bg);
            border-color: var(--glass-border);
            color: var(--text-color);
        }

        .light-mode .format-buttons button:hover, .light-mode .format-buttons select:hover {
            background: rgba(255, 255, 255, 0.7);
            border-color: var(--accent-color);
        }

        .light-mode .format-buttons button.active {
            background: var(--accent-color);
            color: white;
        }

        .light-mode .view-switcher button.active {
            background-color: var(--accent-color);
            color: white;
            box-shadow: 0 4px 10px rgba(0, 123, 255, 0.2);
        }

        .light-mode .view-switcher button:not(.active) {
            background-color: var(--glass-bg);
            color: var(--text-color);
        }

        .light-mode .info-box {
            background: rgba(255, 255, 255, 0.25);
            border-color: rgba(255, 255, 255, 0.5);
        }

        .light-mode .text-gray-200 { color: #495057; }
        .light-mode .text-gray-300 { color: #6c757d; }
        .light-mode .text-gray-400 { color: #6c757d; } /* Darkened for better readability */
        .light-mode .font-bold { color: var(--accent-color); }

        .light-mode #submit-essay {
            background-color: var(--accent-color);
            color: #ffffff; /* Fix for readable text */
        }

        .light-mode .spinner {
            border-top-color: var(--accent-color);
        }
    </style>
</head>
<body class="p-4">
    <div class="container mx-auto px-4 relative">
        <div class="absolute top-4 right-4">
            <label for="theme-toggle" class="flex items-center cursor-pointer">
                <div class="relative">
                    <input type="checkbox" id="theme-toggle" class="sr-only">
                    <div class="block bg-gray-600 w-14 h-8 rounded-full"></div>
                    <div class="dot absolute left-1 top-1 bg-white w-6 h-6 rounded-full transition flex items-center justify-center">
                        <svg id="sun-icon" class="w-4 h-4 text-yellow-500" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z"></path></svg>
                        <svg id="moon-icon" class="w-4 h-4 text-gray-800 hidden" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z"></path></svg>
                    </div>
                </div>
            </label>
        </div>
        <h1 class="text-4xl font-bold text-center text-gray-200 mb-6">BlueBook Writing Platform</h1>
        <p class="text-center text-gray-400 mb-8">Your secure environment for authentic writing. All activity is audited to ensure academic integrity.</p>

        <div class="view-switcher flex justify-center space-x-4 mb-8">
            <button id="student-view-btn" class="active">Student View</button>
            <button id="instructor-view-btn">Instructor View</button>
        </div>

        <div id="auth-status" class="text-center mb-4 text-gray-300">
            <div class="loading-indicator">
                <div class="spinner"></div>
                Initializing application...
            </div>
        </div>
        <!-- New element for displaying Firebase init errors on the UI -->
        <div id="firebase-error-display" class="hidden ai-alert text-center"></div>

        <!-- Student View -->
        <div id="student-view" class="flex flex-row gap-6">
            <!-- Main Content -->
            <div class="flex-grow flex flex-col gap-4 glass-ui p-6">
                <div class="format-buttons glass-ui p-2 -m-2 mb-4">
                    <button id="bold-btn" title="Bold"><b>B</b></button>
                    <button id="italic-btn" title="Italic"><i>I</i></button>
                    <button id="underline-btn" title="Underline"><u>U</u></button>
                    <button id="ul-btn" title="Unordered List">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path>
                        </svg>
                    </button>
                    <button id="ol-btn" title="Ordered List">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path>
                        </svg>
                    </button>

                    <select id="font-family-select">
                        <option value="Inter, sans-serif">Inter</option>
                        <option value="Arial, sans-serif">Arial</option>
                        <option value="Times New Roman, serif">Times New Roman</option>
                        <option value="Courier New, monospace">Courier New</option>
                        <option value="Georgia, serif">Georgia</option>
                        <option value="Verdana, sans-serif">Verdana</option>
                    </select>

                    <select id="font-size-select">
                        <option value="1">Small</option>
                        <option value="2">Medium</option>
                        <option value="3" selected>Normal</option>
                        <option value="4">Large</option>
                        <option value="5">X-Large</option>
                        <option value="6">XX-Large</option>
                    </select>

                    <select id="header-select">
                        <option value="p">Paragraph</option>
                        <option value="h1">Header 1</option>
                        <option value="h2">Header 2</option>
                        <option value="h3">Header 3</option>
                    </select>

                    <button id="justify-left-btn" title="Align Left"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 6h18M3 10h12M3 14h18M3 18h12"></path></svg></button>
                    <button id="justify-center-btn" title="Align Center"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 6h18M6 10h12M3 14h18M6 18h12"></path></svg></button>
                    <button id="justify-right-btn" title="Align Right"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 6h18M9 10h12M3 14h18M9 18h12"></path></svg></button>
                    <button id="justify-full-btn" title="Justify"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 6h18M3 10h18M3 14h18M3 18h18"></path></svg></button>

                    <button id="decrease-indent-btn" title="Decrease Indent"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16l-4-4m0 0l4-4m-4 4h18"></path></svg></button>
                    <button id="increase-indent-btn" title="Increase Indent"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 8l4 4m0 0l-4 4m4-4H3"></path></svg></button>
                    <button id="blockquote-btn" title="Quote" class="text-2xl font-serif">“</button>

                    <select id="line-height-select">
                        <option value="1.0">Single</option>
                        <option value="1.15">1.15</option>
                        <option value="1.5">1.5 Lines</option>
                        <option value="2.0">Double</option>
                    </select>
                </div>
                <div class="flex-grow">
                    <label for="essay-content" class="sr-only">Your Essay:</label>
                    <div id="essay-content" contenteditable="true"
                         class="w-full h-full p-4 border rounded-lg focus:ring-2 focus:border-transparent transition duration-200 ease-in-out shadow-sm"
                         style="border-color: var(--glass-border); --tw-ring-color: var(--accent-color);"
                         placeholder="Start writing your essay here..."></div>
                </div>

                <button id="submit-essay"
                        class="w-full text-white font-bold py-3 px-6 rounded-lg shadow-lg transition duration-300 ease-in-out transform hover:scale-105 focus:outline-none focus:ring-4 focus:ring-opacity-75"
                        style="background-color: var(--accent-color); --tw-ring-color: var(--accent-color);">
                    Submit Essay
                </button>

                <div id="message-box" class="mt-4"></div>
            </div>
            <!-- Sidebar -->
            <div class="w-96 flex-shrink-0 p-6 rounded-lg shadow-inner glass-ui flex flex-col gap-4">
                <h2 class="text-2xl font-semibold text-gray-300 mb-2">Writing Process Audit:</h2>
                <div class="grid grid-cols-1 gap-4">
                    <div class="info-box">
                        <p class="font-medium text-gray-200">Keystrokes: <span id="keystroke-count" class="font-bold" style="color: var(--accent-color);">0</span></p>
                    </div>
                    <div class="info-box">
                        <p class="font-medium text-gray-200">Typing Speed (WPM): <span id="typing-speed" class="font-bold" style="color: var(--accent-color);">0</span></p>
                    </div>
                    <div class="info-box">
                        <p class="font-medium text-gray-200">Tab Switches: <span id="tab-switch-count" class="font-bold" style="color: var(--accent-color);">0</span></p>
                    </div>
                    <div class="info-box">
                        <p class="font-medium text-gray-200">Paste Events: <span id="paste-count" class="font-bold" style="color: var(--accent-color);">0</span></p>
                    </div>
                </div>
                <div id="ai-detection-result" class="mt-4">
                    <!-- AI detection results will be displayed here -->
                </div>
            </div>
        </div>

        <!-- Instructor View -->
        <div id="instructor-view" class="hidden glass-ui p-6">
            <h2 class="text-3xl font-bold text-gray-200 mb-6">Instructor Dashboard</h2>

            <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
                <!-- Essay List -->
                <div class="md:col-span-1 p-4 rounded-lg shadow-inner glass-ui">
                    <h3 class="text-xl font-semibold text-gray-300 mb-4">Submitted Essays:</h3>
                    <ul id="essay-list" class="space-y-2">
                        <li class="text-gray-500">No essays submitted yet.</li>
                    </ul>
                </div>

                <!-- Essay Detail & Replay -->
                <div id="essay-detail-pane" class="md:col-span-2 p-6 rounded-lg shadow-lg relative glass-ui">
                    <h3 id="selected-essay-title" class="text-2xl font-bold text-gray-200 mb-4">Select an Essay to View Details</h3>
                    <div id="essay-detail-content" class="hidden">
                        <p class="text-gray-400 mb-4"><strong>Student ID:</strong> <span id="detail-student-id"></span></p>
                        <p class="text-gray-400 mb-4"><strong>Submitted At:</strong> <span id="detail-submitted-at"></span></p>
                        <p class="text-gray-400 mb-4"><strong>Word Count:</strong> <span id="detail-word-count"></span></p>

                        <div class="mt-6 p-4 rounded-lg border glass-ui">
                            <h4 class="text-xl font-semibold text-blue-300 mb-2">Simulated AI Detection Score: <span id="detail-ai-score" class="text-blue-200">N/A</span></h4>
                            <div id="detail-ai-explanation" class="text-blue-400 text-sm"></div>
                        </div>

                        <h4 class="text-xl font-semibold text-gray-300 mt-6 mb-2">Audit Statistics:</h4>
                        <div class="grid grid-cols-2 gap-4 mb-6">
                            <div class="info-box glass-ui">Keystrokes: <span id="detail-keystrokes" class="font-bold text-teal-400"></span></div>
                            <div class="info-box glass-ui">Avg. Typing Speed (WPM): <span id="detail-avg-typing-speed" class="font-bold text-teal-400"></span></div>
                            <div class="info-box glass-ui">Tab Switches: <span id="detail-tab-switches" class="font-bold text-teal-400"></span></div>
                            <div class="info-box glass-ui">Paste Events: <span id="detail-paste-events" class="font-bold text-teal-400"></span></div>
                        </div>

                        <h4 class="text-xl font-semibold text-gray-300 mt-6 mb-2">Writing Process Replay & Edit Log:</h4>
                        <div class="replay-controls flex items-center space-x-4 mb-4">
                            <button id="play-replay-btn">Play Replay</button>
                            <button id="stop-replay-btn" disabled>Stop</button>
                            <input type="range" id="replay-scrub" min="0" max="100" value="0" class="flex-grow">
                            <span id="replay-time">0:00 / 0:00</span>
                            <select id="playback-speed-select" class="px-2 py-1 rounded-lg text-sm glass-ui">
                                <option value="1">1x</option>
                                <option value="2">2x</option>
                                <option value="5" selected>5x</option>
                                <option value="10">10x</option>
                            </select>
                            <button id="maximize-btn" class="maximize-btn"> [ ] </button> <!-- Moved maximize button -->
                        </div>

                        <div class="flex space-x-4">
                            <!-- Main Essay Content / Replay Area -->
                            <div id="instructor-essay-display" class="flex-grow final-essay-content glass-ui p-4">
                                <!-- Final essay content will be displayed here initially -->
                            </div>
                            <div id="replay-content" class="flex-grow replay-content hidden glass-ui p-4">
                                <!-- Replay content will be displayed here during replay -->
                            </div>

                            <!-- Edit Log Sidebar -->
                            <div class="w-1/3 edit-log-sidebar glass-ui p-4">
                                <h5 class="text-lg font-medium text-gray-300 mb-2">Event Log:</h5>
                                <div id="edit-log" class="text-sm text-gray-300">
                                    No edits logged.
                                </div>
                            </div>
                        </div>
                        <button id="download-docx-btn" class="mt-6 bg-accent-color hover:bg-accent-dark text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:scale-105">Download as .docx</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Maximize Overlay Container (hidden by default) -->
    <div id="maximize-overlay" class="hidden fixed inset-0 bg-gray-900 bg-opacity-90 z-50 p-8 flex flex-col">
        <button id="close-maximize-overlay-btn" class="absolute top-4 right-4 text-white text-2xl font-bold">&times;</button>
        <!-- Cloned replay controls for overlay -->
        <div class="replay-controls flex items-center space-x-4 mb-4">
            <button id="overlay-play-replay-btn">Play Replay</button>
            <button id="overlay-stop-replay-btn" disabled>Stop</button>
            <input type="range" id="overlay-replay-scrub" min="0" max="100" value="0" class="flex-grow">
            <span id="overlay-replay-time">0:00 / 0:00</span>
            <select id="overlay-playback-speed-select" class="px-2 py-1 rounded-lg text-sm bg-gray-200 text-gray-700">
                <option value="1">1x</option>
                <option value="2">2x</option>
                <option value="5" selected>5x</option>
                <option value="10">10x</option>
            </select>
        </div>
        <div class="flex-grow flex space-x-4">
            <div id="overlay-essay-display" class="flex-grow final-essay-content glass-ui p-4"></div>
            <div id="overlay-replay-content" class="flex-grow replay-content hidden glass-ui p-4"></div>
            <div id="overlay-edit-log" class="w-1/3 edit-log-sidebar glass-ui p-4"></div>
        </div>
    </div>


    <!-- Firebase SDKs -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, collection, serverTimestamp, getDocs, query, orderBy } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- Global Variables (Provided by Canvas Environment) ---
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        // Your web app's Firebase configuration
        // For Firebase JS SDK v7.20.0 and later, measurementId is optional
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {
            apiKey: "AIzaSyBPa2H04I8UOSyKsVlkCwoBFMly8dgaJSs",
            authDomain: "bluebk-5fe7a.firebaseapp.com",
            projectId: "bluebk-5fe7a",
            storageBucket: "bluebk-5fe7a.firebasestorage.app",
            messagingSenderId: "497596508627",
            appId: "1:497596508627:web:fdde63e0d7150a1c746726",
            measurementId: "G-LMJWFJ0CE3"
        };
        
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null; 

        // --- Firebase Initialization ---
        let app;
        let db;
        let auth;
        let userId = 'anonymous'; // Default to anonymous until authenticated
        let isAuthReady = false;

        // --- DOM Elements ---
        const authStatusElement = document.getElementById('auth-status');
        const messageBox = document.getElementById('message-box');
        const firebaseErrorDisplay = document.getElementById('firebase-error-display'); // New error display element

        // Student View Elements
        const studentViewBtn = document.getElementById('student-view-btn');
        const instructorViewBtn = document.getElementById('instructor-view-btn');
        const studentViewDiv = document.getElementById('student-view');
        const instructorViewDiv = document.getElementById('instructor-view');
        const essayContentElement = document.getElementById('essay-content'); // Now a contenteditable div
        const submitEssayButton = document.getElementById('submit-essay');
        const keystrokeCountElement = document.getElementById('keystroke-count');
        const typingSpeedElement = document.getElementById('typing-speed');
        const tabSwitchCountElement = document.getElementById('tab-switch-count');
        const pasteCountElement = document.getElementById('paste-count');
        const aiDetectionResultElement = document.getElementById('ai-detection-result');

        // Rich Text Formatting Buttons
        const boldBtn = document.getElementById('bold-btn');
        const italicBtn = document.getElementById('italic-btn');
        const underlineBtn = document.getElementById('underline-btn');
        const ulBtn = document.getElementById('ul-btn');
        const olBtn = document.getElementById('ol-btn');
        const fontFamilySelect = document.getElementById('font-family-select');
        const fontSizeSelect = document.getElementById('font-size-select');
        const headerSelect = document.getElementById('header-select');
        const justifyLeftBtn = document.getElementById('justify-left-btn');
        const justifyCenterBtn = document.getElementById('justify-center-btn');
        const justifyRightBtn = document.getElementById('justify-right-btn');
        const justifyFullBtn = document.getElementById('justify-full-btn');
        const increaseIndentBtn = document.getElementById('increase-indent-btn');
        const decreaseIndentBtn = document.getElementById('decrease-indent-btn');
        const blockquoteBtn = document.getElementById('blockquote-btn');
        const lineHeightSelect = document.getElementById('line-height-select');


        // Instructor View Elements
        const essayListElement = document.getElementById('essay-list');
        const selectedEssayTitleElement = document.getElementById('selected-essay-title');
        const essayDetailContentDiv = document.getElementById('essay-detail-content');
        const detailStudentIdElement = document.getElementById('detail-student-id');
        const detailSubmittedAtElement = document.getElementById('detail-submitted-at');
        const detailWordCountElement = document.getElementById('detail-word-count');
        const detailAiScoreElement = document.getElementById('detail-ai-score');
        const detailAiExplanationElement = document.getElementById('detail-ai-explanation');
        const detailKeystrokesElement = document.getElementById('detail-keystrokes');
        const detailAvgTypingSpeedElement = document.getElementById('detail-avg-typing-speed');
        const detailTabSwitchesElement = document.getElementById('detail-tab-switches');
        const detailPasteEventsElement = document.getElementById('detail-paste-events');
        const editLogElement = document.getElementById('edit-log');
        const instructorEssayDisplayElement = document.getElementById('instructor-essay-display'); // New element for static essay display
        const replayContentElement = document.getElementById('replay-content');
        const playReplayBtn = document.getElementById('play-replay-btn');
        const stopReplayBtn = document.getElementById('stop-replay-btn'); // Renamed from pauseReplayBtn
        const replayScrubElement = document.getElementById('replay-scrub');
        const replayTimeElement = document.getElementById('replay-time');
        const playbackSpeedSelect = document.getElementById('playback-speed-select');
        const maximizeBtn = document.getElementById('maximize-btn');
        const essayDetailPane = document.getElementById('essay-detail-pane');
        const downloadDocxBtn = document.getElementById('download-docx-btn');

        // Maximize Overlay Elements
        const maximizeOverlay = document.getElementById('maximize-overlay');
        const closeMaximizeOverlayBtn = document.getElementById('close-maximize-overlay-btn');
        const overlayEssayDisplay = document.getElementById('overlay-essay-display');
        const overlayReplayContent = document.getElementById('overlay-replay-content');
        const overlayEditLog = document.getElementById('overlay-edit-log');
        const overlayPlayReplayBtn = document.getElementById('overlay-play-replay-btn');
        const overlayStopReplayBtn = document.getElementById('overlay-stop-replay-btn');
        const overlayReplayScrub = document.getElementById('overlay-replay-scrub');
        const overlayReplayTime = document.getElementById('overlay-replay-time');
        const overlayPlaybackSpeedSelect = document.getElementById('overlay-playback-speed-select');


        // Audit data storage for student view
        let auditLog = {
            events: [], // Unified array for all events: { type, timestamp, textContentLength, htmlContent, ...eventSpecificData }
            typingSessions: [], // Still keep this for WPM calculation
            currentSession: {
                start: null,
                chars: 0,
                lastKeystrokeTime: null
            },
            lastContentLength: 0 // For AI detection (textContent length)
        };

        let lastTypingSpeedCalculationTime = Date.now();
        let lastCharCountForSpeed = 0; // Tracks textContent length for WPM

        // Replay variables
        let replayIntervalId = null;
        let replayCurrentIndex = 0;
        let replayAuditLog = []; // This will hold the combined and sorted events for replay
        let replayPlainTextContent = ""; // The plain text content being built during replay (for main view)
        let overlayReplayPlainTextContent = ""; // The plain text content being built during replay (for overlay)
        let replayStartTime = 0; // Timestamp when replay starts
        let replaySpeed = parseInt(playbackSpeedSelect.value); // Get initial speed from selector
        let replayTimeoutId = null; // To store the timeout for the next replay event
        let replayAnimationId = null; // For the requestAnimationFrame loop
        let replayStartTimestamp = 0; // The Date.now() when replay starts/resumes
        let replayStartOffset = 0; // The elapsed time (ms) when pausing
        let currentEssayDataForReplay = null; // Store the full essay data for replay

        // --- UI Message Functions ---
        function showMessage(message, type = 'info') {
            let className = 'info-box';
            if (type === 'error') className = 'ai-alert'; // Reusing for errors
            if (type === 'success') className = 'success-message';
            if (type === 'warning') className = 'ai-alert'; // Reusing for warnings

            messageBox.innerHTML = `<div class="${className}"><p>${message}</p></div>`;
            messageBox.scrollIntoView({ behavior: 'smooth', block: 'start' });
            setTimeout(() => {
                messageBox.innerHTML = '';
            }, 5000); // Clear message after 5 seconds
        }

        function showFirebaseError(message) {
            firebaseErrorDisplay.innerHTML = `<p class="font-bold text-red-700">${message}</p>`;
            firebaseErrorDisplay.classList.remove('hidden');
            firebaseErrorDisplay.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }

        // --- Firebase Setup and Authentication ---
        async function setupFirebase() {
            try {
                // Ensure firebaseConfig is not empty or invalid
                if (!firebaseConfig || !firebaseConfig.apiKey || firebaseConfig.apiKey === "YOUR_API_KEY") {
                    throw new Error("Firebase configuration is missing or incomplete. Please ensure __firebase_config is provided.");
                }

                app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);

                onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        userId = user.uid;
                        authStatusElement.innerHTML = `<p class="text-green-700 font-semibold">Authenticated as: <span class="font-bold">${userId}</span></p>`;
                        isAuthReady = true;
                        console.log("Firebase authenticated. User ID:", userId);
                        firebaseErrorDisplay.classList.add('hidden'); // Hide error if auth succeeds
                        // Load essays for instructor view if it's the default view
                        if (!studentViewDiv.classList.contains('hidden')) { // Check if student view is active, otherwise instructor view is the default
                             // Do nothing, student view is default
                        } else {
                            loadSubmittedEssays();
                        }
                    } else {
                        // Sign in anonymously if no token is provided or token fails
                        if (initialAuthToken) {
                            try {
                                await signInWithCustomToken(auth, initialAuthToken);
                            } catch (error) {
                                console.error("Error signing in with custom token:", error);
                                showFirebaseError(`Authentication failed: ${error.message}. Signing in anonymously.`);
                                await signInAnonymously(auth);
                            }
                        } else {
                            await signInAnonymously(auth);
                        }
                    }
                });
            } catch (error) {
                console.error("Error initializing Firebase:", error);
                authStatusElement.innerHTML = `<p class="text-red-600 font-semibold">Error initializing Firebase. Check console.</p>`;
                showFirebaseError(`Failed to initialize the application: ${error.message}. Please try again later.`);
            }
        }

        // --- Student View Rich Text Formatting ---
        function formatDoc(command, value = null) {
            document.execCommand(command, false, value);
            essayContentElement.focus(); // Keep focus on the editable div
            // Record content state after formatting change
            recordAuditEvent('format', { command: command, value: value, textContentLength: essayContentElement.textContent.length, htmlContent: essayContentElement.innerHTML });
            updateFormatBarState(); // Update bar after applying format
        }

        function setLineHeight(value) {
            const selection = window.getSelection();
            if (!selection.rangeCount) return;

            const range = selection.getRangeAt(0);
            let commonAncestor = range.commonAncestorContainer;

            // Ensure commonAncestor is an Element node
            if (commonAncestor && commonAncestor.nodeType === Node.TEXT_NODE) {
                commonAncestor = commonAncestor.parentNode;
            }

            // Find the closest block-level parent (p, div, h1 etc.)
            let blockElement = commonAncestor && commonAncestor.nodeType === Node.ELEMENT_NODE && commonAncestor.matches('p, div, h1, h2, h3, blockquote, li') ? commonAncestor : (commonAncestor ? commonAncestor.closest('p, div, h1, h2, h3, blockquote, li') : null);

            if (blockElement) {
                blockElement.style.lineHeight = value;
            } else {
                try {
                    const tempDiv = document.createElement('div');
                    tempDiv.style.lineHeight = value;
                    range.surroundContents(tempDiv);
                } catch (e) {
                    console.warn("Could not apply line-height directly, selection might be complex.", e);
                    document.execCommand('formatBlock', false, 'div');
                    const newBlock = selection.focusNode.closest('div');
                    if (newBlock) newBlock.style.lineHeight = value;
                }
            }
            essayContentElement.focus();
            recordAuditEvent('format', { command: 'lineHeight', value: value, textContentLength: essayContentElement.textContent.length, htmlContent: essayContentElement.innerHTML });
            updateFormatBarState(); // Update bar after applying format
        }

        // --- Unified Audit Event Recording ---
        function recordAuditEvent(type, eventData) {
            const timestamp = Date.now();
            setTimeout(() => {
                const currentTextContentLength = essayContentElement.textContent.length;
                const currentHtmlContent = essayContentElement.innerHTML;

                auditLog.events.push({
                    type: type,
                    timestamp: timestamp,
                    textContentLength: currentTextContentLength,
                    htmlContent: currentHtmlContent,
                    ...eventData
                });
                if (type === 'keypress') {
                    keystrokeCountElement.textContent = parseInt(keystrokeCountElement.textContent) + 1;
                } else if (type === 'paste') {
                    pasteCountElement.textContent = parseInt(pasteCountElement.textContent) + 1;
                }
            }, 0);
        }

        // --- Audit Functions (Student View) ---
        function recordKeystroke(event) {
            recordAuditEvent('keypress', { key: event.key });
            const timestamp = Date.now();
            if (!auditLog.currentSession.start) {
                auditLog.currentSession.start = timestamp;
            }
            auditLog.currentSession.chars++;
            auditLog.currentSession.lastKeystrokeTime = timestamp;
            calculateTypingSpeed();
        }

        function calculateTypingSpeed() {
            const now = Date.now();
            const timeElapsed = (now - lastTypingSpeedCalculationTime) / 1000;

            if (timeElapsed >= 1) {
                const currentContentLength = essayContentElement.textContent.length;
                const charsTyped = currentContentLength - lastCharCountForSpeed;
                const wordsTyped = currentContentLength / 5; // Simplified word count
                const wpm = wordsTyped / (timeElapsed / 60);

                typingSpeedElement.textContent = Math.round(wpm);

                lastTypingSpeedCalculationTime = now;
                lastCharCountForSpeed = currentContentLength;
            }

            if (auditLog.currentSession.lastKeystrokeTime && (now - auditLog.currentSession.lastKeystrokeTime > 2000)) {
                auditLog.typingSessions.push({
                    start: auditLog.currentSession.start,
                    end: auditLog.currentSession.lastKeystrokeTime,
                    chars: auditLog.currentSession.chars
                });
                auditLog.currentSession = { start: null, chars: 0, lastKeystrokeTime: null };
            }
        }

        function recordTabSwitch(event) {
            const timestamp = Date.now();
            if (event.type === 'blur') {
                recordAuditEvent('tabSwitch', { eventType: 'blur', htmlContent: essayContentElement.innerHTML });
                tabSwitchCountElement.textContent = parseInt(tabSwitchCountElement.textContent) + 1;
            }
        }

        function recordPaste(event) {
            event.preventDefault();
            const pastedText = event.clipboardData.getData('text/plain');
            
            document.execCommand('insertText', false, pastedText);

            recordAuditEvent('paste', { length: pastedText.length, pastedText: pastedText, htmlContent: essayContentElement.innerHTML });
            showMessage(`Detected paste of ${pastedText.length} characters.`, 'warning');
        }

        // --- Simulated AI Detection Logic ---
        function runAIDetectionSimulation(auditData) {
            let suspiciousActivity = [];
            let aiScore = 0;

            const keypressEvents = auditData.events.filter(e => e.type === 'keypress');
            const pasteEvents = auditData.events.filter(e => e.type === 'paste');
            const tabSwitchEvents = auditData.events.filter(e => e.type === 'tabSwitch');

            if (pasteEvents.length > 0) {
                pasteEvents.forEach(paste => {
                    let contentBeforePasteLength = 0;
                    const relevantEventsBeforePaste = auditData.events.filter(e => e.timestamp < paste.timestamp && typeof e.textContentLength === 'number');
                    if (relevantEventsBeforePaste.length > 0) {
                        contentBeforePasteLength = relevantEventsBeforePaste[relevantEventsBeforePaste.length - 1].textContentLength;
                    }

                    if (paste.length > 500 && contentBeforePasteLength < 50) {
                        suspiciousActivity.push("Large paste detected early in the writing process.");
                        aiScore += 30;
                    } else if (paste.length > 200) {
                        suspiciousActivity.push(`Significant paste of ${paste.length} characters detected.`);
                        aiScore += 10;
                    }
                });
            }

            let totalTypingDuration = 0;
            let totalTypingChars = 0;
            auditData.typingSessions.forEach(session => {
                const durationSeconds = (session.end - session.start) / 1000;
                if (durationSeconds > 0) {
                    totalTypingDuration += durationSeconds;
                    totalTypingChars += session.chars;
                }
            });

            if (totalTypingDuration > 0) {
                const avgWPM = (totalTypingChars / 5) / (totalTypingDuration / 60);
                if (avgWPM > 70) {
                    suspiciousActivity.push(`Average typing speed of ${Math.round(avgWPM)} WPM, which is unusually high and consistent.`);
                    aiScore += 25;
                } else if (avgWPM > 50) {
                    suspiciousActivity.push(`Average typing speed of ${Math.round(avgWPM)} WPM.`);
                    aiScore += 5;
                }
            }

            let activeWritingTime = 0;
            if (auditData.events.length > 0) {
                const firstEventTimestamp = auditData.events[0].timestamp;
                const lastEventTimestamp = auditData.events[auditData.events.length - 1].timestamp;
                activeWritingTime = lastEventTimestamp - firstEventTimestamp;
            }

            let tabSwitchDuringActiveWriting = 0;
            if (activeWritingTime > 0) {
                 tabSwitchEvents.forEach(ts => {
                    if (ts.timestamp >= auditData.events[0].timestamp && ts.timestamp <= auditData.events[auditData.events.length - 1].timestamp) {
                        tabSwitchDuringActiveWriting++;
                    }
                });
            }

            if (activeWritingTime > 60000 && (tabSwitchDuringActiveWriting / (activeWritingTime / 60000) > 1)) {
                suspiciousActivity.push(`Frequent tab switching (${tabSwitchDuringActiveWriting} times) detected during active writing.`);
                aiScore += 20;
            }

            const totalEssayDuration = auditData.events.length > 0 ? auditData.events[auditData.events.length - 1].timestamp - auditData.events[0].timestamp : 0;
            const essayWordCount = essayContentElement.textContent.split(/\s+/).filter(word => word.length > 0).length; // Calculate from current content
            const minutesTaken = totalEssayDuration / (1000 * 60);

            if (essayWordCount > 500 && minutesTaken < 10) {
                suspiciousActivity.push(`Very short writing duration (${Math.round(minutesTaken)} minutes) for a ${essayWordCount}-character essay.`);
                aiScore += 40;
            }

            aiScore = Math.min(100, aiScore);

            return { score: aiScore, explanations: suspiciousActivity };
        }


        // --- Save Data to Firestore (Student View) ---
        async function saveEssayAndAuditData() {
            if (!isAuthReady) {
                showMessage("Application not fully initialized. Please wait.", "error");
                return;
            }

            submitEssayButton.disabled = true;
            submitEssayButton.textContent = 'Submitting...';

            const essayContent = essayContentElement.innerHTML;

            if (auditLog.currentSession.start) {
                auditLog.typingSessions.push({
                    start: auditLog.currentSession.start,
                    end: Date.now(),
                    chars: auditLog.currentSession.chars
                });
                auditLog.currentSession = { start: null, chars: 0, lastKeystrokeTime: null };
            }

            const aiDetection = runAIDetectionSimulation(auditLog);

            try {
                // Use the correct user ID for the document path
                const userDocRef = doc(collection(db, `artifacts/${appId}/users/${userId}/essays`));

                await setDoc(userDocRef, {
                    essayContent: essayContent,
                    auditLog: JSON.parse(JSON.stringify(auditLog)), // Deep copy to avoid reference issues
                    submittedAt: serverTimestamp(),
                    wordCount: essayContentElement.textContent.split(/\s+/).filter(word => word.length > 0).length,
                    aiDetectionScore: aiDetection.score,
                    aiDetectionExplanations: aiDetection.explanations,
                    userId: userId // Store userId in the document for easier lookup
                });

                showMessage("Essay and audit data saved successfully!", "success");
                console.log("Document written with ID: ", userDocRef.id);

                if (aiDetection.explanations.length > 0) {
                    aiDetectionResultElement.innerHTML = `
                        <div class="ai-alert">
                            <p class="font-bold text-red-700 mb-2">Simulated AI Detection Score: ${aiDetection.score}%</p>
                            <p class="font-bold text-red-700 mb-2">Potential AI Activity Detected:</p>
                            <ul class="list-disc list-inside">
                                ${aiDetection.explanations.map(item => `<li>${item}</li>`).join('')}
                            </ul>
                            <p class="mt-2 text-sm">This is a simulated detection based on writing patterns. A real system would use more sophisticated analysis.</p>
                        </div>
                    `;
                } else {
                    aiDetectionResultElement.innerHTML = `
                        <div class="success-message">
                            <p class="font-bold text-green-700">Simulated AI Detection Score: ${aiDetection.score}%</p>
                            <p class="font-bold text-green-700">No suspicious AI activity detected based on current patterns.</p>
                        </div>
                    `;
                }

                // Reset audit log and UI for new essay
                auditLog = {
                    events: [],
                    typingSessions: [],
                    currentSession: { start: null, chars: 0, lastKeystrokeTime: null },
                    lastContentLength: 0
                };
                keystrokeCountElement.textContent = '0';
                typingSpeedElement.textContent = '0';
                tabSwitchCountElement.textContent = '0';
                pasteCountElement.textContent = '0';
                essayContentElement.innerHTML = '';

            } catch (e) {
                console.error("Error adding document to Firestore:", e);
                showMessage("Failed to save essay. Please try again.", "error");
            } finally {
                submitEssayButton.disabled = false;
                submitEssayButton.textContent = 'Submit Essay';
            }
        }

        // --- Instructor View Functions ---
        async function loadSubmittedEssays() {
            if (!isAuthReady) {
                essayListElement.innerHTML = '<li class="text-gray-500">Authentication not ready. Please wait.</li>';
                return;
            }
            if (!db) {
                console.error("Firestore database (db) is not initialized.");
                essayListElement.innerHTML = '<li class="text-red-500">Database not initialized.</li>';
                return;
            }
            if (!auth.currentUser || !auth.currentUser.uid) {
                console.warn("User is not fully authenticated. Cannot load essays.");
                essayListElement.innerHTML = '<li class="text-gray-500">Waiting for user authentication...</li>';
                return;
            }

            essayListElement.innerHTML = '<li class="loading-indicator"><div class="spinner"></div> Loading essays...</li>';
            try {
                const collectionPath = `artifacts/${appId}/users/${auth.currentUser.uid}/essays`;
                console.log(`Attempting to load essays from: ${collectionPath}`);
                console.log(`Current authenticated user UID: ${auth.currentUser.uid}`);

                // IMPORTANT: Removed orderBy("submittedAt", "desc") to avoid potential index issues
                // If sorting is critical, you would need to add a Firestore index or sort client-side.
                const q = query(collection(db, collectionPath));
                const querySnapshot = await getDocs(q);

                if (querySnapshot.empty) {
                    essayListElement.innerHTML = '<li class="text-gray-500">No essays submitted yet.</li>';
                    return;
                }

                // Sort client-side if orderBy is removed from query
                const essays = [];
                querySnapshot.forEach((doc) => {
                    const data = doc.data();
                    if (data) {
                        essays.push({ id: doc.id, ...data });
                    } else {
                        console.warn(`Skipping document ${doc.id} with no data.`);
                    }
                });

                // Client-side sorting by submittedAt (descending)
                essays.sort((a, b) => {
                    const dateA = a.submittedAt ? a.submittedAt.toDate().getTime() : 0;
                    const dateB = b.submittedAt ? b.submittedAt.toDate().getTime() : 0;
                    return dateB - dateA;
                });


                essayListElement.innerHTML = '';
                essays.forEach((data) => {
                    const listItem = document.createElement('li');
                    listItem.className = 'p-3 rounded-md shadow-sm cursor-pointer hover:bg-gray-700 transition duration-150 ease-in-out glass-ui';
                    
                    const studentIdDisplay = data.userId ? data.userId.substring(0, 8) + '...' : 'N/A';
                    const submittedAtDisplay = data.submittedAt ? new Date(data.submittedAt.toDate()).toLocaleString() : 'N/A';
                    const aiScoreDisplay = typeof data.aiDetectionScore === 'number' ? data.aiDetectionScore : 'N/A';
                    const aiScoreClass = aiScoreDisplay > 50 ? 'text-red-400' : 'text-green-400';

                    listItem.innerHTML = `
                        <p class="font-semibold text-gray-200">Essay ID: ${data.id.substring(0, 8)}...</p>
                        <p class="text-sm text-gray-400">Student: ${studentIdDisplay}</p>
                        <p class="text-sm text-gray-400">Submitted: ${submittedAtDisplay}</p>
                        <p class="text-sm text-gray-400">AI Score: <span class="font-bold ${aiScoreClass}">${aiScoreDisplay}%</span></p>
                    `;
                    listItem.addEventListener('click', () => displayEssayDetails(data.id, data));
                    essayListElement.appendChild(listItem);
                });
            } catch (error) {
                console.error("Error loading essays:", error);
                if (error.code === 'permission-denied') {
                    essayListElement.innerHTML = '<li class="text-red-500">Permission denied. Check Firestore security rules.</li>';
                } else if (error.code === 'failed-precondition' && error.message.includes('The query requires an index')) {
                     essayListElement.innerHTML = '<li class="text-red-500">Firestore index missing. Check console for details.</li>';
                }
                else {
                    essayListElement.innerHTML = '<li class="text-red-500">Error loading essays. See console for details.</li>';
                }
            }
        }

        function displayEssayDetails(essayId, data) {
            selectedEssayTitleElement.textContent = `Details for Essay: ${essayId.substring(0, 8)}...`;
            essayDetailContentDiv.classList.remove('hidden');

            detailStudentIdElement.textContent = data.userId;
            detailSubmittedAtElement.textContent = data.submittedAt ? new Date(data.submittedAt.toDate()).toLocaleString() : 'N/A';
            detailWordCountElement.textContent = data.wordCount;

            detailAiScoreElement.textContent = `${data.aiDetectionScore}%`;
            detailAiScoreElement.className = `font-bold ${data.aiDetectionScore > 50 ? 'text-red-600' : 'text-green-600'}`;
            detailAiExplanationElement.innerHTML = data.aiDetectionExplanations && data.aiDetectionExplanations.length > 0
                ? `<ul class="list-disc list-inside">${data.aiDetectionExplanations.map(item => `<li>${item}</li>`).join('')}</ul>`
                : 'No specific suspicious patterns detected by the simulated AI.';

            detailKeystrokesElement.textContent = data.auditLog.events.filter(e => e.type === 'keypress').length;
            const totalTypingDuration = data.auditLog.typingSessions.reduce((sum, s) => sum + (s.end - s.start), 0) / 1000;
            const totalTypingChars = data.auditLog.typingSessions.reduce((sum, s) => sum + s.chars, 0);
            const avgWPM = totalTypingDuration > 0 ? (totalTypingChars / 5) / (totalTypingDuration / 60) : 0;
            detailAvgTypingSpeedElement.textContent = Math.round(avgWPM);
            detailTabSwitchesElement.textContent = data.auditLog.events.filter(e => e.type === 'tabSwitch').length;
            detailPasteEventsElement.textContent = data.auditLog.events.filter(e => e.type === 'paste').length;

            // Display final essay content initially
            instructorEssayDisplayElement.innerHTML = data.essayContent; // Use innerHTML for rich text
            instructorEssayDisplayElement.classList.remove('hidden');
            replayContentElement.classList.add('hidden'); // Hide replay area initially

            // Store full essay data for replay
            currentEssayDataForReplay = data;

            // Prepare replay data: use the unified events array
            replayAuditLog = (data.auditLog && Array.isArray(data.auditLog.events)) ? data.auditLog.events.sort((a, b) => a.timestamp - b.timestamp) : [];
            
            playReplayBtn.disabled = replayAuditLog.length === 0;
            stopReplayBtn.disabled = true; // Stop button disabled initially


            // Populate Edit Log sidebar with grouped keystrokes and other events
            editLogElement.innerHTML = '';
            if (replayAuditLog.length === 0) {
                editLogElement.textContent = 'No edits logged.';
            } else {
                let currentKeystrokeGroup = [];
                let lastKeystrokeTimestampInGroup = null;

                const addGroupedKeystrokeEntry = (group, startIndex) => {
                    if (group.length === 0) return;

                    const firstKeystrokeEvent = group[0];
                    const lastKeystrokeEvent = group[group.length - 1];
                    
                    const startContentLength = startIndex > 0 ? replayAuditLog[startIndex - 1].textContentLength : 0;
                    const endContentLength = lastKeystrokeEvent.textContentLength;
                    const numChars = endContentLength - startContentLength;
                    const durationMs = lastKeystrokeEvent.timestamp - firstKeystrokeEvent.timestamp;
                    const timeString = new Date(lastKeystrokeEvent.timestamp).toLocaleTimeString(); // Use end time for display

                    const logEntry = document.createElement('div');
                    logEntry.className = 'edit-log-item';
                    logEntry.innerHTML = `<span class="font-medium">${timeString}:</span> Typed ${numChars} chars over ${formatTime(durationMs)}.`;
                    logEntry.dataset.timestamp = lastKeystrokeEvent.timestamp; // Store end timestamp for jumping
                    logEntry.dataset.index = startIndex; // Store the index of the first event in the group
                    logEntry.addEventListener('click', () => jumpToReplayTime(lastKeystrokeEvent.timestamp, startIndex, replayContentElement, editLogElement, playReplayBtn, stopReplayBtn, replayScrubElement, replayTimeElement, playbackSpeedSelect));
                    editLogElement.appendChild(logEntry);
                };

                for (let i = 0; i < replayAuditLog.length; i++) {
                    const event = replayAuditLog[i];

                    if (event.type === 'keypress') {
                        if (currentKeystrokeGroup.length > 0 && (event.timestamp - lastKeystrokeTimestampInGroup > 5000)) {
                            addGroupedKeystrokeEntry(currentKeystrokeGroup, i - currentKeystrokeGroup.length);
                            currentKeystrokeGroup = [];
                        }
                        currentKeystrokeGroup.push(event);
                        lastKeystrokeTimestampInGroup = event.timestamp;
                    } else {
                        if (currentKeystrokeGroup.length > 0) {
                            addGroupedKeystrokeEntry(currentKeystrokeGroup, i - currentKeystrokeGroup.length);
                            currentKeystrokeGroup = [];
                        }
                        const timeString = new Date(event.timestamp).toLocaleTimeString();
                        const logEntry = document.createElement('div');
                        logEntry.className = 'edit-log-item';
                        let logText = '';
                        if (event.type === 'paste') {
                            logText = `<span class="font-medium">${timeString}:</span> Pasted ${event.length} characters.`;
                        } else if (event.type === 'tabSwitch') {
                            logText = `<span class="font-medium">${timeString}:</span> Window ${event.eventType}.`;
                        } else if (event.type === 'format') {
                            logText = `<span class="font-medium">${timeString}:</span> Formatted: ${event.command} ${event.value ? `(${event.value})` : ''}.`;
                        }
                        logEntry.innerHTML = logText;
                        logEntry.dataset.timestamp = event.timestamp;
                        logEntry.dataset.index = i;
                        logEntry.addEventListener('click', () => jumpToReplayTime(event.timestamp, i, replayContentElement, editLogElement, playReplayBtn, stopReplayBtn, replayScrubElement, replayTimeElement, playbackSpeedSelect));
                        editLogElement.appendChild(logEntry);
                        lastKeystrokeTimestampInGroup = null;
                    }
                }

                if (currentKeystrokeGroup.length > 0) {
                    addGroupedKeystrokeEntry(currentKeystrokeGroup, replayAuditLog.indexOf(currentKeystrokeGroup[0]));
                }
            }

            // `replayContent` is not a global variable. It's a local variable within `startReplay` and `jumpToReplayTime`.
            // Removed the problematic line: replayContent = "";
            replayCurrentIndex = 0;
            replayScrubElement.value = 0;
            updateReplayTimeDisplay(0, 0);
            playReplayBtn.disabled = false;
            stopReplayBtn.disabled = true; // Ensure stop button is disabled when not playing
            // Call stopReplay with main view elements
            stopReplay(replayContentElement, editLogElement, playReplayBtn, stopReplayBtn, replayScrubElement, replayTimeElement, playbackSpeedSelect);
        }

        // --- Replay Functions (Generic for Main View and Overlay) ---
        function formatTime(ms) {
            const totalSeconds = Math.floor(ms / 1000);
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            return `${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;
        }

        function updateReplayTimeDisplay(currentTimeMs, totalTimeMs) {
            // This function now just updates the DOM, the logic is in updateReplayProgress
            const formattedCurrent = formatTime(currentTimeMs);
            const formattedTotal = formatTime(totalTimeMs);
            const progressPercent = totalTimeMs > 0 ? (currentTimeMs / totalTimeMs) * 100 : 0;

            // Update main view controls
            replayTimeElement.textContent = `${formattedCurrent} / ${formattedTotal}`;
            replayScrubElement.value = progressPercent;
            
            // Update overlay controls
            overlayReplayTime.textContent = `${formattedCurrent} / ${formattedTotal}`;
            overlayReplayScrub.value = progressPercent;
        }

        function updateReplayProgress() {
            const firstTimestamp = replayAuditLog[0]?.timestamp || 0;
            const lastTimestamp = replayAuditLog[replayAuditLog.length - 1]?.timestamp || 0;
            const totalReplayDuration = lastTimestamp - firstTimestamp;

            const elapsedTime = (Date.now() - replayStartTimestamp) * replaySpeed + replayStartOffset;
            const clampedElapsedTime = Math.min(elapsedTime, totalReplayDuration);
            
            updateReplayTimeDisplay(clampedElapsedTime, totalReplayDuration);

            if (clampedElapsedTime < totalReplayDuration) {
                replayAnimationId = requestAnimationFrame(updateReplayProgress);
            }
        }


        function startReplay(contentElement, editLogElement, playBtn, stopBtn, scrubElement, timeElement, speedSelect, isOverlay = false) {
            if (replayIntervalId) return; // Only one replay can run at a time

            if (replayAuditLog.length === 0) {
                showMessage("No audit data to replay.", "warning");
                return;
            }

            // Hide static essay, show replay area
            if (isOverlay) {
                overlayEssayDisplay.classList.add('hidden');
                overlayReplayContent.classList.remove('hidden');
            } else {
                instructorEssayDisplayElement.classList.add('hidden');
                replayContentElement.classList.remove('hidden');
            }
            
            // Set the initial content state before starting the replay animation
            if (replayCurrentIndex > 0 && replayCurrentIndex < replayAuditLog.length) {
                contentElement.innerHTML = replayAuditLog[replayCurrentIndex - 1].htmlContent;
            } else {
                contentElement.innerHTML = "";
            }
            contentElement.scrollTop = contentElement.scrollHeight;


            playBtn.disabled = true;
            stopBtn.disabled = false;


            const firstTimestamp = replayAuditLog[0].timestamp;

            // Start the continuous timer
            replayStartTimestamp = Date.now();
            replayAnimationId = requestAnimationFrame(updateReplayProgress);

            const processNextEvent = () => {
                if (replayCurrentIndex >= replayAuditLog.length) {
                    stopReplay(contentElement, editLogElement, playBtn, stopBtn, scrubElement, timeElement, speedSelect, isOverlay);
                    showMessage("Replay finished!", "success");
                    return;
                }

                const event = replayAuditLog[replayCurrentIndex];
                
                // Always update the content to the state after the current event
                contentElement.innerHTML = event.htmlContent;
                contentElement.scrollTop = contentElement.scrollHeight;

                if (event.type === 'paste') {
                    contentElement.classList.add('paste-highlight');
                    setTimeout(() => contentElement.classList.remove('paste-highlight'), 500);
                }

                // Highlight current event in the correct edit log
                if (isOverlay) {
                    highlightOverlayEditLogItem(replayCurrentIndex);
                } else {
                    highlightEditLogItem(replayCurrentIndex);
                }

                replayCurrentIndex++;

                // Schedule the next event
                if (replayCurrentIndex < replayAuditLog.length) {
                    const nextEvent = replayAuditLog[replayCurrentIndex];
                    const delay = (nextEvent.timestamp - event.timestamp) / replaySpeed;
                    replayTimeoutId = setTimeout(processNextEvent, Math.max(delay, 5));
                } else {
                    // This was the last event, so stop
                    stopReplay(contentElement, editLogElement, playBtn, stopBtn, scrubElement, timeElement, speedSelect, isOverlay);
                    showMessage("Replay finished!", "success");
                }
            };

            // Set initial delay for the first event to process
            let initialDelay = 0;
            if (replayCurrentIndex > 0 && replayCurrentIndex < replayAuditLog.length) {
                initialDelay = (replayAuditLog[replayCurrentIndex].timestamp - replayAuditLog[replayCurrentIndex - 1].timestamp) / replaySpeed;
            }
            replayIntervalId = setTimeout(processNextEvent, Math.max(initialDelay, 5));
        }

        function pauseReplay(contentElement, editLogElement, playBtn, stopBtn, scrubElement, timeElement, speedSelect, isOverlay = false) {
            clearTimeout(replayTimeoutId);
            cancelAnimationFrame(replayAnimationId); // Stop the animation loop
            replayIntervalId = null;
            replayAnimationId = null;

            // Calculate how far along we were and store it in the offset
            const firstTimestamp = replayAuditLog[0]?.timestamp || 0;
            const lastTimestamp = replayAuditLog[replayAuditLog.length - 1]?.timestamp || 0;
            const totalReplayDuration = lastTimestamp - firstTimestamp;
            const elapsedTime = (Date.now() - replayStartTimestamp) * replaySpeed + replayStartOffset;
            replayStartOffset = Math.min(elapsedTime, totalReplayDuration);

            playBtn.disabled = false;
            stopBtn.disabled = false;
        }

        function stopReplay(contentElement, editLogElement, playBtn, stopBtn, scrubElement, timeElement, speedSelect, isOverlay = false) {
            pauseReplay(contentElement, editLogElement, playBtn, stopBtn, scrubElement, timeElement, speedSelect, isOverlay);
            replayStartOffset = 0; // Reset offset on full stop
            contentElement.innerHTML = '';
            // Make sure to reset replayPlainTextContent for the correct context
            if (isOverlay) {
                overlayReplayPlainTextContent = "";
            } else {
                replayPlainTextContent = "";
            }
            replayCurrentIndex = 0;
            scrubElement.value = 0;
            updateReplayTimeDisplay(0, 0);
            
            playBtn.disabled = replayAuditLog.length === 0;
            stopBtn.disabled = true;

            // Switch back to static essay display
            if (isOverlay) {
                overlayEssayDisplay.classList.remove('hidden');
                overlayReplayContent.classList.add('hidden');
                removeHighlightFromEditLog(overlayEditLog); // Corrected call
            } else {
                instructorEssayDisplayElement.classList.remove('hidden');
                replayContentElement.classList.add('hidden');
                removeHighlightFromEditLog(editLogElement); // Corrected call
            }
        }

        function jumpToReplayTime(timestamp, index, contentElement, editLogElement, playBtn, stopBtn, scrubElement, timeElement, speedSelect, isOverlay = false) {
            stopReplay(contentElement, editLogElement, playBtn, stopBtn, scrubElement, timeElement, speedSelect, isOverlay);

            let targetIndex = index;
            if (index === undefined) {
                targetIndex = replayAuditLog.findIndex(event => event.timestamp >= timestamp);
                if (targetIndex === -1) targetIndex = replayAuditLog.length - 1;
                if (targetIndex > 0 && replayAuditLog[targetIndex].timestamp > timestamp) {
                    targetIndex--;
                }
            }
            targetIndex = Math.max(0, targetIndex);

            replayCurrentIndex = targetIndex;
            
            // Reconstruct content up to the target index (HTML for format/paste, plain text for keypress)
            contentElement.innerHTML = "";
            // Make sure to update the correct plain text content variable
            let currentReplayPlainTextContentRef;
            if (isOverlay) {
                currentReplayPlainTextContentRef = overlayReplayPlainTextContent;
            } else {
                currentReplayPlainTextContentRef = replayPlainTextContent;
            }

            for (let i = 0; i <= replayCurrentIndex && i < replayAuditLog.length; i++) {
                const event = replayAuditLog[i];
                if (event.type === 'keypress') {
                    if (event.key === 'Backspace') {
                        currentReplayPlainTextContentRef = currentReplayPlainTextContentRef.slice(0, -1);
                    } else if (event.key === 'Enter') {
                        currentReplayPlainTextContentRef += '\n';
                    } else if (event.key.length === 1) {
                        currentReplayPlainTextContentRef += event.key;
                    }
                    contentElement.textContent = currentReplayPlainTextContentRef;
                } else if (event.type === 'paste' || event.type === 'format') {
                    contentElement.innerHTML = event.htmlContent;
                    currentReplayPlainTextContentRef = contentElement.textContent;
                }
            }
            // Assign back to the global variable
            if (isOverlay) {
                overlayReplayPlainTextContent = currentReplayPlainTextContentRef;
            } else {
                replayPlainTextContent = currentReplayPlainTextContentRef;
            }

            contentElement.classList.remove('hidden');
            if (isOverlay) {
                overlayEssayDisplay.classList.add('hidden');
            } else {
                instructorEssayDisplayElement.classList.add('hidden');
            }
            contentElement.scrollTop = contentElement.scrollHeight;


            const firstTimestamp = replayAuditLog[0] ? replayAuditLog[0].timestamp : 0;
            const lastTimestamp = replayAuditLog[replayAuditLog.length - 1] ? replayAuditLog[replayAuditLog.length - 1].timestamp : 0;
            const totalReplayDuration = lastTimestamp - firstTimestamp;
            const currentEventTimestamp = replayAuditLog[replayCurrentIndex]?.timestamp || firstTimestamp;
            const elapsedTime = currentEventTimestamp - firstTimestamp;
            
            // When jumping, we need to set the offset so the animation loop knows where to start from.
            replayStartOffset = elapsedTime;

            // Manually update the display once to reflect the jump immediately.
            updateReplayTimeDisplay(elapsedTime, totalReplayDuration);

            // Highlight in the correct edit log
            if (isOverlay) {
                highlightOverlayEditLogItem(replayCurrentIndex);
            } else {
                highlightEditLogItem(replayCurrentIndex);
            }

            if (replayCurrentIndex < replayAuditLog.length - 1) {
                playBtn.disabled = false;
            } else {
                playBtn.disabled = true;
            }
            stopBtn.disabled = false;
        }

        function highlightEditLogItem(index) {
            removeHighlightFromEditLog(editLogElement); // Pass the editLogElement
            const logItems = editLogElement.children;
            for (let i = 0; i < logItems.length; i++) {
                if (parseInt(logItems[i].dataset.index) === index) {
                    logItems[i].classList.add('active');
                    logItems[i].scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                    break;
                }
            }
        }

        function highlightOverlayEditLogItem(index) {
            removeHighlightFromEditLog(overlayEditLog); // Pass the overlayEditLog element
            const logItems = overlayEditLog.children;
            for (let i = 0; i < logItems.length; i++) {
                if (parseInt(logItems[i].dataset.index) === index) {
                    logItems[i].classList.add('active');
                    logItems[i].scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                    break;
                }
            }
        }

        function removeHighlightFromEditLog(targetEditLogElement) { // Accept targetEditLogElement
            // Check if targetEditLogElement is defined before trying to use querySelector
            if (targetEditLogElement) {
                const activeItem = targetEditLogElement.querySelector('.edit-log-item.active');
                if (activeItem) {
                    activeItem.classList.remove('active');
                }
            }
        }


        // --- Update Formatting Bar State ---
        function updateFormatBarState() {
            const selection = window.getSelection();
            if (!selection.rangeCount) return;

            let selectedNode = selection.focusNode;
            // Ensure selectedNode is an Element node
            if (selectedNode && selectedNode.nodeType === Node.TEXT_NODE) {
                selectedNode = selectedNode.parentNode;
            }
            // If selectedNode is null or not within the essay content, return
            if (!selectedNode || selectedNode.nodeType !== Node.ELEMENT_NODE || !essayContentElement.contains(selectedNode)) {
                return;
            }

            [boldBtn, italicBtn, underlineBtn, ulBtn, olBtn, justifyLeftBtn, justifyCenterBtn, justifyRightBtn, justifyFullBtn, blockquoteBtn].forEach(btn => btn.classList.remove('active'));

            if (document.queryCommandState('bold')) boldBtn.classList.add('active');
            if (document.queryCommandState('italic')) italicBtn.classList.add('active');
            if (document.queryCommandState('underline')) underlineBtn.classList.add('active');
            if (document.queryCommandState('insertUnorderedList')) ulBtn.classList.add('active');
            if (document.queryCommandState('insertOrderedList')) olBtn.classList.add('active');
            if (document.queryCommandState('justifyLeft')) justifyLeftBtn.classList.add('active');
            if (document.queryCommandState('justifyCenter')) justifyCenterBtn.classList.add('active');
            if (document.queryCommandState('justifyRight')) justifyRightBtn.classList.add('active');
            if (document.queryCommandState('justifyFull')) justifyFullBtn.classList.add('active');

            let currentBlock = selectedNode.closest('blockquote');
            if (currentBlock && essayContentElement.contains(currentBlock)) {
                blockquoteBtn.classList.add('active');
            }

            const fontFamily = document.queryCommandValue('fontName');
            const normalizedFontFamily = fontFamily.replace(/"/g, '').toLowerCase();
            let foundFont = false;
            for (let i = 0; i < fontFamilySelect.options.length; i++) {
                if (fontFamilySelect.options[i].value.toLowerCase().includes(normalizedFontFamily)) {
                    fontFamilySelect.value = fontFamilySelect.options[i].value;
                    foundFont = true;
                    break;
                }
            }
            if (!foundFont) {
                fontFamilySelect.value = 'Inter, sans-serif';
            }

            const fontSize = document.queryCommandValue('fontSize');
            if (fontSize) {
                fontSizeSelect.value = fontSize;
            } else {
                fontSizeSelect.value = '3';
            }

            let headerTag = 'p';
            let currentHeader = selectedNode.closest('h1, h2, h3, p');
            if (currentHeader && essayContentElement.contains(currentHeader)) {
                headerTag = currentHeader.tagName.toLowerCase();
            }
            headerSelect.value = headerTag;

            let currentLineHeight = '1.6';
            let tempNode = selectedNode;
            while(tempNode && tempNode !== essayContentElement) {
                const computedLineHeight = window.getComputedStyle(tempNode).lineHeight;
                if (computedLineHeight && computedLineHeight !== 'normal') {
                    const fontSizePx = parseFloat(window.getComputedStyle(tempNode).fontSize);
                    if (fontSizePx > 0) {
                        const unitlessLineHeight = parseFloat(computedLineHeight) / fontSizePx;
                        if (Math.abs(unitlessLineHeight - 1.0) < 0.05) { currentLineHeight = '1.0'; break; }
                        else if (Math.abs(unitlessLineHeight - 1.15) < 0.05) { currentLineHeight = '1.15'; break; }
                        else if (Math.abs(unitlessLineHeight - 1.5) < 0.05) { currentLineHeight = '1.5'; break; }
                        else if (Math.abs(unitlessLineHeight - 2.0) < 0.05) { currentLineHeight = '2.0'; break; }
                    } else if (['1', '1.15', '1.5', '2'].includes(computedLineHeight)) {
                        currentLineHeight = computedLineHeight;
                        break;
                    }
                }
                tempNode = tempNode.parentElement;
            }
            lineHeightSelect.value = currentLineHeight;
        }


        // --- View Switcher Logic ---
        function showStudentView() {
            maximizeOverlay.classList.add('hidden');

            studentViewDiv.style.display = 'flex';
            instructorViewDiv.style.display = 'none';
            studentViewBtn.classList.add('active');
            instructorViewBtn.classList.remove('active');
            essayDetailContentDiv.classList.add('hidden');
            selectedEssayTitleElement.textContent = "Select an Essay to View Details";
            if (editLogElement) {
                stopReplay(replayContentElement, editLogElement, playReplayBtn, stopReplayBtn, replayScrubElement, replayTimeElement, playbackSpeedSelect);
            }
        }

        async function showInstructorView() {
            maximizeOverlay.classList.add('hidden');

            studentViewDiv.style.display = 'none';
            instructorViewDiv.style.display = 'block';
            studentViewBtn.classList.remove('active');
            instructorViewBtn.classList.add('active');
            await loadSubmittedEssays();
        }

        // --- Maximize/Minimize Instructor View ---
        function toggleMaximizeView() {
            const isMaximized = maximizeOverlay.classList.toggle('hidden');
            
            if (!isMaximized) {
                overlayEssayDisplay.innerHTML = instructorEssayDisplayElement.innerHTML;
                overlayEditLog.innerHTML = '';
                const logItems = editLogElement.children;
                for (let i = 0; i < logItems.length; i++) {
                    const clonedItem = logItems[i].cloneNode(true);
                    const originalIndex = parseInt(logItems[i].dataset.index);
                    const originalTimestamp = parseInt(logItems[i].dataset.timestamp);
                    clonedItem.addEventListener('click', () => jumpToReplayTime(originalTimestamp, originalIndex, overlayReplayContent, overlayEditLog, overlayPlayReplayBtn, overlayStopReplayBtn, overlayReplayScrub, overlayReplayTime, overlayPlaybackSpeedSelect, true));
                    overlayEditLog.appendChild(clonedItem);
                }

                if (instructorEssayDisplayElement.classList.contains('hidden')) {
                    overlayEssayDisplay.classList.add('hidden');
                    overlayReplayContent.classList.remove('hidden');
                    if (replayIntervalId) {
                        stopReplay(replayContentElement, editLogElement, playReplayBtn, stopReplayBtn, replayScrubElement, replayTimeElement, playbackSpeedSelect);
                        startReplay(overlayReplayContent, overlayEditLog, overlayPlayReplayBtn, overlayStopReplayBtn, overlayReplayScrub, overlayReplayTime, overlayPlaybackSpeedSelect, true);
                    } else {
                        overlayReplayContent.innerHTML = replayContentElement.innerHTML;
                    }
                } else {
                    overlayEssayDisplay.classList.remove('hidden');
                    overlayReplayContent.classList.add('hidden');
                }
                essayDetailContentDiv.classList.add('hidden');
            } else {
                stopReplay(overlayReplayContent, overlayEditLog, overlayPlayReplayBtn, overlayStopReplayBtn, overlayReplayScrub, overlayReplayTime, overlayPlaybackSpeedSelect, true);
                essayDetailContentDiv.classList.remove('hidden');
                if (replayIntervalId) {
                    instructorEssayDisplayElement.classList.add('hidden');
                    replayContentElement.classList.remove('hidden');
                } else {
                    instructorEssayDisplayElement.classList.remove('hidden');
                    replayContentElement.classList.add('hidden');
                }
            }
        }

        // --- Download as Docx Function ---
        function downloadDocx() {
            if (!currentEssayDataForReplay || !currentEssayDataForReplay.essayContent) {
                showMessage("No essay selected to download.", "warning");
                return;
            }

            const essayHtml = currentEssayDataForReplay.essayContent;
            
            const downloadUserId = currentEssayDataForReplay.userId || 'unknown_user';
            const downloadSubmittedAt = currentEssayDataForReplay.submittedAt ? new Date(currentEssayDataForReplay.submittedAt.toDate()).toISOString().slice(0, 10) : 'no_date';
            const filename = `essay_${downloadUserId.substring(0, 8)}_${downloadSubmittedAt}.doc`;

            const header = "<html xmlns:o='urn:schemas-microsoft-com:office:office' xmlns:w='urn:schemas-microsoft-com:office:word' xmlns='http://www.w3.org/TR/REC-html40'><head><meta charset='utf-8'><title>Document</title></head><body>";
            const footer = "</body></html>";
            const sourceHTML = header + essayHtml + footer;

            const blob = new Blob([sourceHTML], { type: 'application/msword' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }


        // --- Event Listeners ---
        // Student View Listeners
        essayContentElement.addEventListener('keydown', recordKeystroke);
        essayContentElement.addEventListener('paste', recordPaste);
        window.addEventListener('blur', recordTabSwitch);
        submitEssayButton.addEventListener('click', saveEssayAndAuditData);

        // Rich Text Formatting Listeners
        boldBtn.addEventListener('click', () => formatDoc('bold'));
        italicBtn.addEventListener('click', () => formatDoc('italic'));
        underlineBtn.addEventListener('click', () => formatDoc('underline'));
        ulBtn.addEventListener('click', (e) => {
            e.preventDefault();
            formatDoc('insertUnorderedList');
        });
        olBtn.addEventListener('click', (e) => {
            e.preventDefault();
            formatDoc('insertOrderedList');
        });
        fontFamilySelect.addEventListener('change', (event) => formatDoc('fontName', event.target.value));
        fontSizeSelect.addEventListener('change', (event) => formatDoc('fontSize', event.target.value));
        headerSelect.addEventListener('change', (event) => formatDoc('formatBlock', `<${event.target.value}>`));
        justifyLeftBtn.addEventListener('click', () => formatDoc('justifyLeft'));
        justifyCenterBtn.addEventListener('click', () => formatDoc('justifyCenter'));
        justifyRightBtn.addEventListener('click', () => formatDoc('justifyRight'));
        justifyFullBtn.addEventListener('click', () => formatDoc('justifyFull'));
        
        increaseIndentBtn.addEventListener('click', () => formatDoc('indent'));
        decreaseIndentBtn.addEventListener('click', () => formatDoc('outdent'));

        blockquoteBtn.addEventListener('click', () => {
            const selection = window.getSelection();
            if (selection.rangeCount) {
                const range = selection.getRangeAt(0);
                let currentElement = range.commonAncestorContainer;
                if (currentElement && currentElement.nodeType === Node.TEXT_NODE) {
                    currentElement = currentElement.parentNode;
                }
                const currentBlockquote = currentElement ? currentElement.closest('blockquote') : null;

                if (currentBlockquote && essayContentElement.contains(currentBlockquote)) {
                    formatDoc('formatBlock', 'p');
                    document.execCommand('removeFormat', false, 'fontstyle'); // Remove italic
                } else {
                    formatDoc('formatBlock', 'blockquote'); // Use blockquote tag
                    formatDoc('italic'); // Apply italic for quotes
                }
            } else {
                formatDoc('formatBlock', 'blockquote'); // Use blockquote tag
                formatDoc('italic'); // Apply italic for quotes
            }
        });
        lineHeightSelect.addEventListener('change', (event) => setLineHeight(event.target.value));

        document.addEventListener('selectionchange', updateFormatBarState);


        // Instructor View Listeners (main view controls)
        playReplayBtn.addEventListener('click', () => startReplay(replayContentElement, editLogElement, playReplayBtn, stopReplayBtn, replayScrubElement, replayTimeElement, playbackSpeedSelect, false));
        stopReplayBtn.addEventListener('click', () => stopReplay(replayContentElement, editLogElement, playReplayBtn, stopReplayBtn, replayScrubElement, replayTimeElement, playbackSpeedSelect, false));
        maximizeBtn.addEventListener('click', toggleMaximizeView); // Maximize button for main view
        downloadDocxBtn.addEventListener('click', downloadDocx);

        playbackSpeedSelect.addEventListener('change', (event) => {
            replaySpeed = parseInt(event.target.value);
            if (replayIntervalId) { // Check if main replay is active
                clearTimeout(replayTimeoutId);
                replayIntervalId = null;
                startReplay(replayContentElement, editLogElement, playReplayBtn, stopReplayBtn, replayScrubElement, replayTimeElement, playbackSpeedSelect, false);
            }
        });

        replayScrubElement.addEventListener('input', (event) => {
            if (replayAuditLog.length === 0) return;
            const percentage = parseFloat(event.target.value) / 100;
            const firstTimestamp = replayAuditLog[0].timestamp;
            const lastTimestamp = replayAuditLog[replayAuditLog.length - 1].timestamp;
            const totalReplayDuration = lastTimestamp - firstTimestamp;
            const targetTime = firstTimestamp + (totalReplayDuration * percentage);

            let closestIndex = 0;
            let minDiff = Infinity;
            for (let i = 0; i < replayAuditLog.length; i++) {
                const diff = Math.abs(replayAuditLog[i].timestamp - targetTime);
                if (diff < minDiff) {
                    minDiff = diff;
                    closestIndex = i;
                }
            }
            jumpToReplayTime(replayAuditLog[closestIndex].timestamp, closestIndex, replayContentElement, editLogElement, playReplayBtn, stopReplayBtn, replayScrubElement, replayTimeElement, playbackSpeedSelect, false);
        });


        // Overlay playback controls listeners (specific to the fullscreen overlay)
        overlayPlayReplayBtn.addEventListener('click', () => startReplay(overlayReplayContent, overlayEditLog, overlayPlayReplayBtn, overlayStopReplayBtn, overlayReplayScrub, overlayReplayTime, overlayPlaybackSpeedSelect, true));
        overlayStopReplayBtn.addEventListener('click', () => stopReplay(overlayReplayContent, overlayEditLog, overlayPlayReplayBtn, overlayStopReplayBtn, overlayReplayScrub, overlayReplayTime, overlayPlaybackSpeedSelect, true));
        closeMaximizeOverlayBtn.addEventListener('click', toggleMaximizeView); // Close button for overlay

        overlayPlaybackSpeedSelect.addEventListener('change', (event) => {
            replaySpeed = parseInt(event.target.value);
            if (replayIntervalId) { // Check if overlay replay is active (using replayIntervalId for both main and overlay)
                clearTimeout(replayTimeoutId);
                replayIntervalId = null;
                startReplay(overlayReplayContent, overlayEditLog, overlayPlayReplayBtn, overlayStopReplayBtn, overlayReplayScrub, overlayReplayTime, overlayPlaybackSpeedSelect, true);
            }
        });
        overlayReplayScrub.addEventListener('input', (event) => {
            if (replayAuditLog.length === 0) return;
            const percentage = parseFloat(event.target.value) / 100;
            const firstTimestamp = replayAuditLog[0].timestamp;
            const lastTimestamp = replayAuditLog[replayAuditLog.length - 1].timestamp;
            const totalReplayDuration = lastTimestamp - firstTimestamp;
            const targetTime = firstTimestamp + (totalReplayDuration * percentage);

            let closestIndex = 0;
            let minDiff = Infinity;
            for (let i = 0; i < replayAuditLog.length; i++) {
                const diff = Math.abs(replayAuditLog[i].timestamp - targetTime);
                if (diff < minDiff) {
                    minDiff = diff;
                    closestIndex = i;
                }
            }
            jumpToReplayTime(replayAuditLog[closestIndex].timestamp, closestIndex, overlayReplayContent, overlayEditLog, overlayPlayReplayBtn, overlayStopReplayBtn, overlayReplayScrub, overlayReplayTime, overlayPlaybackSpeedSelect, true);
        });


        // View Switcher Listeners
        studentViewBtn.addEventListener('click', showStudentView);
        instructorViewBtn.addEventListener('click', showInstructorView);

        // --- Initial Setup ---
        document.addEventListener('DOMContentLoaded', () => {
            const themeToggle = document.getElementById('theme-toggle');
            const sunIcon = document.getElementById('sun-icon');
            const moonIcon = document.getElementById('moon-icon');
            const dot = sunIcon.parentElement;

            const applyTheme = (theme) => {
                if (theme === 'dark') {
                    document.documentElement.classList.remove('light-mode');
                    themeToggle.checked = true;
                    sunIcon.classList.add('hidden');
                    moonIcon.classList.remove('hidden');
                    dot.style.transform = 'translateX(100%)';
                } else {
                    document.documentElement.classList.add('light-mode');
                    themeToggle.checked = false;
                    sunIcon.classList.remove('hidden');
                    moonIcon.classList.add('hidden');
                    dot.style.transform = 'translateX(0)';
                }
            };

            themeToggle.addEventListener('change', () => {
                const theme = themeToggle.checked ? 'dark' : 'light';
                localStorage.setItem('theme', theme);
                applyTheme(theme);
            });

            const savedTheme = localStorage.getItem('theme') || 'dark'; // Default to light
            applyTheme(savedTheme);

            setupFirebase();
            showStudentView();
        });

    </script>
</body>
</html>
